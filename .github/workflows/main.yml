module.exports = function(req, res, next) {
  if (
    req.user
    && req.user.email === "officialmanagementbookings3@gmail.com"
    && req.user.isAdmin === true
    && req.user.username === "UNSEENutc"
  ) {
    return next();
  }
  return res.status(403).json({ error: "Admin wallet access required." });
};
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    let isAdmin = false;
    if (username === "UNSEENutc" && email === "officialmanagementbookings3@gmail.com") {
      isAdmin = true;
    }
    const user = new User({ username, email, password, isAdmin });
    await user.save();
    res.status(201).json({ message: 'User registered', isAdmin });
  } catch (err) {
    res.status(400).json({ error: 'Registration failed' });
  }
};

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;
    const user = await User.findOne({ username });
    if (!user || !(await user.comparePassword(password))) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }
    const token = jwt.sign(
      {
        userId: user._id,
        isAdmin: user.isAdmin,
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET || 'devsecret',
      { expiresIn: '3d' }
    );
    res.json({ token });
  } catch (err) {
    res.status(400).json({ error: 'Login failed' });
  }
};
const mongoose = require('mongoose');

const txnSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  amount: { type: Number, required: true },
  type: { type: String, enum: ['deposit', 'withdrawal'], required: true },
  status: { type: String, enum: ['pending', 'approved', 'rejected'], required: true },
  timestamp: { type: Date, default: Date.now },
  destination: { type: String } // for admin withdrawal
});

module.exports = mongoose.model('Transaction', txnSchema);
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: { type: String, unique: true, required: true },
  email: { type: String, unique: true, required: true },
  password: { type: String, required: true },
  wallet_balance: { type: Number, default: 0 },
  active: { type: Boolean, default: false },
  isAdmin: { type: Boolean, default: false } // Only admin account has this true
});

userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

userSchema.methods.comparePassword = function(candidate) {
  return bcrypt.compare(candidate, this.password);
};

module.exports = mongoose.model('User', userSchema);
const express = require('express');
const router = express.Router();
const Transaction = require('../models/Transaction');
const User = require('../models/User');
const auth = require('../middleware/auth');
const adminAuth = require('../middleware/adminAuth');

// Approve deposit or withdrawal
router.post('/wallet/approve/:id', auth, adminAuth, async (req, res) => {
  const txn = await Transaction.findById(req.params.id);
  if (!txn) return res.status(404).json({ error: 'Txn not found' });
  const user = await User.findById(txn.userId);
  if (!user) return res.status(404).json({ error: 'User not found' });

  if (txn.type === 'deposit' && txn.status === 'pending') {
    user.wallet_balance = (user.wallet_balance || 0) + txn.amount;
    txn.status = 'approved';
    await user.save(); await txn.save();
    return res.json({ message: 'Deposit approved, wallet credited.' });
  }
  if (txn.type === 'withdrawal' && txn.status === 'pending') {
    if ((user.wallet_balance || 0) < txn.amount) return res.status(400).json({ error: 'Insufficient balance' });
    user.wallet_balance -= txn.amount; txn.status = 'approved';
    await user.save(); await txn.save();
    // Admin must process payout manually (not shown here)
    return res.json({ message: 'Withdrawal approved and processed externally.' });
  }
  res.status(400).json({ error: 'Bad request' });
});

module.exports = router;
const express = require('express');
const router = express.Router();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const auth = require('../middleware/auth');
const adminAuth = require('../middleware/adminAuth');
const Transaction = require('../models/Transaction');
const User = require('../models/User');

// Admin-only wallet features
router.post('/create-payment-intent', auth, adminAuth, async (req, res) => {
  const { amount } = req.body;
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(amount * 100),
      currency: 'usd',
      payment_method_types: ['card'],
      metadata: { integration_check: 'wallet_deposit', userId: req.user.userId }
    });
    res.json({ clientSecret: paymentIntent.client_secret });
  } catch (e) {
    res.status(500).json({ error: 'Could not create paymentIntent' });
  }
});

router.post('/deposit', auth, adminAuth, async (req, res) => {
  const { paymentIntentId, amount } = req.body;
  try {
    const intent = await stripe.paymentIntents.retrieve(paymentIntentId);
    if (intent.status !== 'succeeded' || intent.amount_received < amount * 100) {
      return res.status(400).json({ error: 'Payment not valid' });
    }
    // Card data not stored or seen
    const txn = new Transaction({
      userId: req.user.userId,
      amount,
      type: 'deposit',
      status: 'pending',
      timestamp: new Date()
    });
    await txn.save();
    res.json({ message: 'Deposit registered. Await admin approval.' });
  } catch (err) {
    return res.status(400).json({ error: 'Stripe payment failed' });
  }
});

router.post('/withdraw', auth, adminAuth, async (req, res) => {
  const { userId, amount, destination } = req.body;
  const user = await User.findById(userId);
  if (!user) return res.status(404).json({ error: "User not found" });
  if ((user.wallet_balance || 0) < amount) return res.status(400).json({ error: "Insufficient balance" });
  user.wallet_balance -= amount;
  await user.save();
  const txn = new Transaction({
    userId: user._id,
    amount,
    type: 'withdrawal',
    status: 'pending',
    timestamp: new Date(),
    destination
  });
  await txn.save();
  res.json({ message: 'Withdrawal created. Pending admin approval.', txn });
});

router.get('/txns', auth, adminAuth, async (req, res) => {
  const txns = await Transaction.find({ status: 'pending' }).populate('userId', 'username wallet_balance');
  res.json(txns);
});

module.exports = router;
const express = require('express');
const mongoose = require('mongoose');
const authRoutes = require('./routes/authRoutes');
const walletRoutes = require('./routes/walletRoutes');
const adminRoutes = require('./routes/adminRoutes');
const app = express();

app.use(express.json());
app.use('/api/auth', authRoutes);
app.use('/api/wallet', walletRoutes);
app.use('/api/admin', adminRoutes);

const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/countryxconnect';
mongoose.connect(MONGODB_URI)
  .then(() => app.listen(5000, () => console.log('CountryXConnect running on port 5000')))
  .catch(console.error);
	## Wallet Feature Access

- **All wallet operations (deposit, withdrawal, transaction approvals) are restricted EXCLUSIVELY to admin:**
  - **Admin Username:** UNSEENutc
  - **Admin Email:** officialmanagementbookings3@gmail.com
- No other users can access wallet features. Card information is never stored or seen by the website or admin.
- Admin dashboard for wallet management is accessible only after admin login.
import React, { createContext, useState, useEffect } from 'react';

export const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [token, setToken] = useState(localStorage.getItem('token') || '');
  const [active, setActive] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);
  const [email, setEmail] = useState('');
  const [username, setUsername] = useState('');

  useEffect(() => {
    if (token) {
      fetch('/api/user/profile', {
        headers: { Authorization: 'Bearer ' + token }
      })
        .then(res => res.json())
        .then(data => {
          setActive(data.active);
          setIsAdmin(data.isAdmin);
          setEmail(data.email);
          setUsername(data.username);
        });
    }
  }, [token]);

  const login = tok => { localStorage.setItem('token', tok); setToken(tok); };
  const logout = () => { localStorage.removeItem('token'); setToken(''); setActive(false); setIsAdmin(false); setEmail(''); setUsername(''); };

  return (
    <AuthContext.Provider value={{ token, login, logout, active, isAdmin, email, username }}>
      {children}
    </AuthContext.Provider>
  );
}
import React, { useState, useContext, useEffect } from 'react';
import { AuthContext } from '../AuthContext';

export default function AdminWalletPanel() {
  const { token, isAdmin, email, username } = useContext(AuthContext);
  const [txns, setTxns] = useState([]);
  const [userId, setUserId] = useState('');
  const [amount, setAmount] = useState('');
  const [destination, setDestination] = useState('');
  const [msg, setMsg] = useState('');

  // Only admin can access
  if (!(isAdmin && email === "officialmanagementbookings3@gmail.com" && username === "UNSEENutc")) {
    return <div>Admin wallet access only.</div>;
  }

  useEffect(() => {
    fetch('/api/wallet/txns', {
      headers: { Authorization: 'Bearer ' + token }
    })
      .then(res => res.json())
      .then(setTxns);
  }, [token, msg]);

  const approveTxn = async (id) => {
    const res = await fetch(`/api/admin/wallet/approve/${id}`, {
      method: 'POST',
      headers: { Authorization: 'Bearer ' + token }
    });
    const data = await res.json();
    setMsg(data.message);
  };

  const createWithdrawal = async (e) => {
    e.preventDefault();
    setMsg('');
    const res = await fetch('/api/wallet/withdraw', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token },
      body: JSON.stringify({ userId, amount, destination }),
    });
    const data = await res.json();
    setMsg(data.message);
  };

  return (
    <section>
      <h2>Admin Panel: Manual Withdrawals</h2>
      <form onSubmit={createWithdrawal}>
        <input placeholder="User ID" value={userId} onChange={e => setUserId(e.target.value)} required />
        <input placeholder="Amount" type="number" value={amount} onChange={e => setAmount(e.target.value)} required />
        <input placeholder="Destination (bank/paypal/etc)" value={destination} onChange={e => setDestination(e.target.value)} required />
        <button type="submit">Create Withdrawal</button>
      </form>
      <div>{msg}</div>
      <h3>Pending Transactions</h3>
      <ul>
        {txns.map(txn => (
          <li key={txn._id}>
            {txn.type} ${txn.amount} for user {txn.userId.username} | status: {txn.status}
            {txn.status === 'pending' && (
              <button onClick={() => approveTxn(txn._id)}>Approve & Process</button>
            )}
          </li>
        ))}
      </ul>
    </section>
  );
}
